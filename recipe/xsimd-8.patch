diff --git a/src/sycomore/epg/simd_api.cpp b/src/sycomore/epg/simd_api.cpp
index 09f4c90..b367fb3 100644
--- a/src/sycomore/epg/simd_api.cpp
+++ b/src/sycomore/epg/simd_api.cpp
@@ -21,7 +21,7 @@ namespace simd_api
 
 template<>
 void
-apply_pulse_d<0>(
+apply_pulse_d<unsupported>(
     std::vector<Complex> const & T,
     Complex * F, Complex * F_star, Complex * Z, unsigned int states_count)
 {
@@ -34,7 +34,7 @@ apply_pulse_d<0>(
 
 template<>
 void
-relaxation_d<0>(
+relaxation_d<unsupported>(
     std::pair<Real, Real> const & E,
     Real * F, Real * F_star, Real * Z, unsigned int states_count)
 {
@@ -48,7 +48,7 @@ relaxation_d<0>(
 
 template<>
 void
-diffusion_d<0>(
+diffusion_d<unsupported>(
     Real delta_k, Real tau, Real D, Real const * k,
     Complex * F, Complex * F_star, Complex * Z, unsigned int states_count)
 {
@@ -62,7 +62,7 @@ diffusion_d<0>(
 
 template<>
 void
-diffusion_3d_b_d<0>(
+diffusion_3d_b_d<unsupported>(
     Real const * k_m, Real const * k_n, Real delta_k_m, Real delta_k_n, 
     Real delta_k_product_term, Real tau, Real D_mn,
     Real * b_L_D, Real * b_T_plus_D, Real * b_T_minus_D,
@@ -76,7 +76,7 @@ diffusion_3d_b_d<0>(
 
 template<>
 void
-diffusion_3d_d<0>(
+diffusion_3d_d<unsupported>(
     Real const * b_L_D, Real const * b_T_plus_D, Real const * b_T_minus_D, 
     Complex * F, Complex * F_star, Complex * Z, unsigned int states_count)
 {
@@ -90,7 +90,7 @@ diffusion_3d_d<0>(
 
 template<>
 void
-off_resonance_d<0>(
+off_resonance_d<unsupported>(
     std::pair<Complex, Complex> const & phi,
     Complex * F, Complex * F_star, Complex * Z, unsigned int states_count)
 {
@@ -103,7 +103,7 @@ off_resonance_d<0>(
 
 template<>
 void
-bulk_motion_d<0>(
+bulk_motion_d<unsupported>(
     Real delta_k, Real v, Real tau, Real const * k,
     Complex * F, Complex * F_star, Complex * Z, unsigned int states_count)
 {
@@ -115,13 +115,13 @@ bulk_motion_d<0>(
  *                          Function table and set-up                          *
  ******************************************************************************/
 
-decltype(&apply_pulse_d<0>) apply_pulse = nullptr;
-decltype(&relaxation_d<0>) relaxation = nullptr;
-decltype(&diffusion_d<0>) diffusion = nullptr;
-decltype(&diffusion_3d_b_d<0>) diffusion_3d_b = nullptr;
-decltype(&diffusion_3d_d<0>) diffusion_3d = nullptr;
-decltype(&off_resonance_d<0>) off_resonance = nullptr;
-decltype(&bulk_motion_d<0>) bulk_motion = nullptr;
+decltype(&apply_pulse_d<unsupported>) apply_pulse = nullptr;
+decltype(&relaxation_d<unsupported>) relaxation = nullptr;
+decltype(&diffusion_d<unsupported>) diffusion = nullptr;
+decltype(&diffusion_3d_b_d<unsupported>) diffusion_3d_b = nullptr;
+decltype(&diffusion_3d_d<unsupported>) diffusion_3d = nullptr;
+decltype(&off_resonance_d<unsupported>) off_resonance = nullptr;
+decltype(&bulk_motion_d<unsupported>) bulk_motion = nullptr;
 
 void set_api(int instruction_set)
 {
diff --git a/src/sycomore/epg/simd_api.h b/src/sycomore/epg/simd_api.h
index 13c146c..1a03c69 100644
--- a/src/sycomore/epg/simd_api.h
+++ b/src/sycomore/epg/simd_api.h
@@ -17,8 +17,8 @@ namespace simd_api
 {
 
 #define SYCOMORE_DEFINE_SIMD_DISPATCHER_FUNCTION(return_, name, parameters) \
-    template<int InstructionSet> return_ name parameters; \
-    template<> return_ name<0> parameters; \
+    template<INSTRUCTION_SET_TYPE InstructionSet> return_ name parameters; \
+    template<> return_ name<unsupported> parameters; \
     extern template return_ name<XSIMD_X86_SSE2_VERSION> parameters; \
     extern template return_ name<XSIMD_X86_AVX_VERSION> parameters; \
     extern template return_ name<XSIMD_X86_AVX512_VERSION> parameters;
@@ -147,13 +147,13 @@ SYCOMORE_DEFINE_SIMD_DISPATCHER_FUNCTION(
  *                          Function table and set-up                          *
  ******************************************************************************/
 
-extern decltype(&apply_pulse_d<0>) apply_pulse;
-extern decltype(&relaxation_d<0>) relaxation;
-extern decltype(&diffusion_d<0>) diffusion;
-extern decltype(&diffusion_3d_b_d<0>) diffusion_3d_b;
-extern decltype(&diffusion_3d_d<0>) diffusion_3d;
-extern decltype(&off_resonance_d<0>) off_resonance;
-extern decltype(&bulk_motion_d<0>) bulk_motion;
+extern decltype(&apply_pulse_d<unsupported>) apply_pulse;
+extern decltype(&relaxation_d<unsupported>) relaxation;
+extern decltype(&diffusion_d<unsupported>) diffusion;
+extern decltype(&diffusion_3d_b_d<unsupported>) diffusion_3d_b;
+extern decltype(&diffusion_3d_d<unsupported>) diffusion_3d;
+extern decltype(&off_resonance_d<unsupported>) off_resonance;
+extern decltype(&bulk_motion_d<unsupported>) bulk_motion;
 
 void set_api(int instruction_set);
 
diff --git a/src/sycomore/epg/simd_api.txx b/src/sycomore/epg/simd_api.txx
index 7699c4e..ef2319a 100644
--- a/src/sycomore/epg/simd_api.txx
+++ b/src/sycomore/epg/simd_api.txx
@@ -49,7 +49,7 @@ void apply_pulse_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 apply_pulse_d(
     std::vector<Complex> const & T,
@@ -88,7 +88,7 @@ void relaxation_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 relaxation_d(
     std::pair<Real, Real> const & E,
@@ -133,7 +133,7 @@ void diffusion_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 diffusion_d(
     Real delta_k, Real tau, Real D, Real const * k,
@@ -179,7 +179,7 @@ void diffusion_3d_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 diffusion_3d_d(
     Real const * b_L_D, Real const * b_T_plus_D, Real const * b_T_minus_D, 
@@ -231,7 +231,7 @@ void diffusion_3d_b_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 diffusion_3d_b_d(
     Real const * k_m, Real const * k_n, Real delta_k_m, Real delta_k_n, 
@@ -275,7 +275,7 @@ void off_resonance_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 off_resonance_d(
     std::pair<Complex, Complex> const & phi,
@@ -320,7 +320,7 @@ void bulk_motion_w(
     }
 }
 
-template<int InstructionSet>
+template<INSTRUCTION_SET_TYPE InstructionSet>
 void
 bulk_motion_d(
     Real delta_k, Real v, Real tau, Real const * k,
diff --git a/src/sycomore/simd.cpp b/src/sycomore/simd.cpp
index 148669e..e9c6139 100644
--- a/src/sycomore/simd.cpp
+++ b/src/sycomore/simd.cpp
@@ -37,6 +37,9 @@ std::vector<unsigned int> get_cpu_info(unsigned int leaf, unsigned int subleaf)
 
 int get_instruction_set()
 {
+#if XSIMD_VERSION_MAJOR >= 8
+    return xsimd::available_architectures().best;
+#else
     auto info = get_cpu_info(1);
     auto const ecx = info[2];
     auto const edx = info[3];
@@ -56,6 +59,7 @@ int get_instruction_set()
     if((ebx & 1<<16) != 0) { instruction_set = XSIMD_X86_AVX512_VERSION; }
     
     return instruction_set;
+#endif
 }
 
 }
diff --git a/src/sycomore/simd.h b/src/sycomore/simd.h
index 02e8a07..c4fecf1 100644
--- a/src/sycomore/simd.h
+++ b/src/sycomore/simd.h
@@ -1,6 +1,8 @@
 #ifndef _aec30e56_9250_476a_8b0d_0981a035c57b
 #define _aec30e56_9250_476a_8b0d_0981a035c57b
 
+// NOTE: include required by one of the trigonometric function in xsimd
+#include <array>
 #include <vector>
 #include <xsimd/xsimd.hpp>
 
@@ -9,10 +11,34 @@
 namespace sycomore
 {
 
+#if XSIMD_VERSION_MAJOR >= 8
+
+#define INSTRUCTION_SET_TYPE typename
+
+using XSIMD_X86_SSE2_VERSION = xsimd::sse2;
+using XSIMD_X86_AVX_VERSION = xsimd::avx;
+using XSIMD_X86_AVX512_VERSION = xsimd::avx512f;
+
+template<typename T>
+using is_batch = xsimd::is_batch<T>;
+
+using unsupported = xsimd::unsupported;
+
+#else
+
+#define INSTRUCTION_SET_TYPE int
+
+template<typename T>
+using is_batch = xsimd::detail::is_simd_type<T>;
+
+int const unsupported = 0;
+
+#endif
+
 namespace simd
 {
 
-template<int InstructionSet, typename T> constexpr std::size_t width();
+template<INSTRUCTION_SET_TYPE InstructionSet, typename T> constexpr std::size_t width();
 
 template<> 
 constexpr std::size_t width<XSIMD_X86_SSE2_VERSION, double>()
@@ -50,8 +76,13 @@ constexpr std::size_t width<XSIMD_X86_AVX512_VERSION, std::complex<double>>()
     return 8;
 }
 
+#if XSIMD_VERSION_MAJOR >= 8
+template<typename T, typename InstructionSet>
+using Batch = xsimd::batch<T, InstructionSet>;
+#else
 template<typename T, int InstructionSet>
 using Batch = xsimd::batch<T, simd::width<InstructionSet, T>()>;
+#endif
 
 /// @brief Return the CPU information given by CPUID (x86/x64 only).
 SYCOMORE_API std::vector<unsigned int> get_cpu_info(
@@ -61,70 +92,74 @@ SYCOMORE_API std::vector<unsigned int> get_cpu_info(
 int get_instruction_set();
 
 template<typename T1, typename T2>
-typename std::enable_if<xsimd::detail::is_simd_type<T2>::value, void>::type
+typename std::enable_if<is_batch<T2>::value, void>::type
 load_aligned(T1 const * source, T2 & destination)
 {
+#if XSIMD_VERSION_MAJOR >= 8
+    destination = destination.load_aligned(source);
+#else
     destination.load_aligned(source);
+#endif
 }
 
 template<typename T>
-typename std::enable_if<!xsimd::detail::is_simd_type<T>::value, void>::type
+typename std::enable_if<!is_batch<T>::value, void>::type
 load_aligned(T const * source, T & destination)
 {
     destination = *source;
 }
 
 template<typename T1, typename T2>
-typename std::enable_if<xsimd::detail::is_simd_type<T1>::value, void>::type
+typename std::enable_if<is_batch<T1>::value, void>::type
 store_aligned(T1 const & source, T2 * destination)
 {
     source.store_aligned(destination);
 }
 
 template<typename T>
-typename std::enable_if<!xsimd::detail::is_simd_type<T>::value, void>::type
+typename std::enable_if<!is_batch<T>::value, void>::type
 store_aligned(T const & source, T * destination)
 {
     *destination = source;
 }
 
 template<typename T>
-typename std::enable_if<xsimd::detail::is_simd_type<T>::value, T>::type
+typename std::enable_if<is_batch<T>::value, T>::type
 pow(T const & base, int exp)
 {
     return xsimd::pow(base, exp);
 }
 
 template<typename T>
-typename std::enable_if<!xsimd::detail::is_simd_type<T>::value, T>::type
+typename std::enable_if<!is_batch<T>::value, T>::type
 pow(T base, int exp)
 {
     return std::pow(base, exp);
 }
 
 template<typename T>
-typename std::enable_if<xsimd::detail::is_simd_type<T>::value, T>::type
+typename std::enable_if<is_batch<T>::value, T>::type
 exp(T const & arg)
 {
     return xsimd::exp(arg);
 }
 
 template<typename T>
-typename std::enable_if<!xsimd::detail::is_simd_type<T>::value, T>::type
+typename std::enable_if<!is_batch<T>::value, T>::type
 exp(T arg)
 {
     return std::exp(arg);
 }
 
 template<typename T>
-typename std::enable_if<xsimd::detail::is_simd_type<T>::value, T>::type
+typename std::enable_if<is_batch<T>::value, T>::type
 conj(T const & arg)
 {
     return xsimd::conj(arg);
 }
 
 template<typename T>
-typename std::enable_if<!xsimd::detail::is_simd_type<T>::value, T>::type
+typename std::enable_if<!is_batch<T>::value, T>::type
 conj(T arg)
 {
     return std::conj(arg);
@@ -134,6 +169,22 @@ conj(T arg)
 
 }
 
+#if XSIMD_VERSION_MAJOR >= 8
+#define SYCOMORE_SET_API_FUNCTION(name) \
+    name = &name##_d<xsimd::unsupported>; \
+    if(instruction_set >= XSIMD_X86_SSE2_VERSION::version()) \
+    { \
+        name = &name##_d<XSIMD_X86_SSE2_VERSION>; \
+    } \
+    if(instruction_set >= XSIMD_X86_AVX_VERSION::version()) \
+    { \
+        name = &name##_d<XSIMD_X86_AVX_VERSION>; \
+    } \
+    if(instruction_set >= XSIMD_X86_AVX512_VERSION::version()) \
+    { \
+        name = &name##_d<XSIMD_X86_AVX512_VERSION>; \
+    }
+#else
 #define SYCOMORE_SET_API_FUNCTION(name) \
     name = &name##_d<0>; \
     if(instruction_set >= XSIMD_X86_SSE2_VERSION) \
@@ -148,5 +199,6 @@ conj(T arg)
     { \
         name = &name##_d<XSIMD_X86_AVX512_VERSION>; \
     }
+#endif
 
 #endif // _aec30e56_9250_476a_8b0d_0981a035c57b
